
chapter20

yield 生成器 只返回一次，实时计算，用法同return。生成器必须用for in 语句读取

re 正则表达式

表2.常用的限定符
代码/语法	说明
*	重复零次或更多次
+	重复一次或更多次
?	重复零次或一次
{n}	重复n次
{n,}	重复n次或更多次
{n,m}	重复n到m次

常用的反义代码

代码/语法	说明
\W	匹配任意不是字母，数字，下划线，汉字的字符
\S	匹配任意不是空白符的字符
\s 空格
\D	匹配任意非数字的字符
\B	匹配不是单词开头或结束的位置
[^x]	匹配除了x以外的任意字符
[^aeiou]	匹配除了aeiou这几个字母以外的任意字符

后向引用：使用小括号，匹配这个子表达式的文本，每个分组会自动拥有一个组号。(exp)

零宽断言：
    (?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。
    比如\b\w+(?=ing\b)【注意：表达式在括号前】匹配以ing结尾的单词的前面部分(除了ing以外的部分)，
    如查找I'm singing while you're dancing.时，它会匹配sing和danc。

    (?<=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。
    比如(?<=\bre)\w+\b【注意：表达式在括号后】会匹配以re开头的单词的后半部分(除了re以外的部分)，
    例如在查找reading a book时，它匹配ading。

正则默认是贪婪的，懒惰：

懒惰限定符
代码/语法	说明
*?	重复任意次，但尽可能少重复
+?	重复1次或更多次，但尽可能少重复
??	重复0次或1次，但尽可能少重复
{n,m}?	重复n到m次，但尽可能少重复
{n,}?	重复n次以上，但尽可能少重复


python用法
先想好使用函数：判断匹配match，断言分组search
正则表达式前用r，表示非转义
python的re即可生成对象，也可以直接当过程函数使用
match：
普通正则，不可使用断言，但是可以使用分组，如使用分组 group(0)为整个表达式匹配，group(1)为第一个分组，以此类推
>>> import re
>>> pattern = re.compile(r'hello')  # 匹配正则
>>> match = pattern.match('hello world!')  # 从0位置字符开始匹配，成功则返回匹配的字符，否则返回None。
                                           # 想要完全匹配，可以在表达式末尾加上边界匹配符'$'
>>> pattern = re.compile(r'hello$')
>>> match = pattern.match('hello world!') # none
>>> match = pattern.match('hello')  # 匹配成功
>>> if match:
    # 使用Match获得分组信息
    print match.group()
hello

>>> pattern = re.compile(r'(hello)\s(world)')
>>> match = pattern.match('hello world!')
>>> print match
<_sre.SRE_Match object at 0x02FD2A40>
>>> match.group(0)
'hello world'
>>> match.group(1)
'hello'
>>> match.group(2)
'world'

group 没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。
groups 以元组形式返回全部分组截获的字符串。
    相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。

findall：
可以使用断言、普通表达式、普通正则
表达式
>>> pattern = re.compile(r'(o)')
>>> pattern.findall(r'hello world!')
['o', 'o']

零宽先
>>> pattern = re.compile(r'\b\w+(?=ing\b)')
>>> pattern.findall(r"I'm singing while you're dancing.")
['sing', 'danc']
零宽度后
>>> pattern = re.compile(r'(?<=i)ng\b')
>>> pattern.findall(r"I'm singing while you're dancing.")
['ng', 'ng']
普通正则
>>> p = re.compile(r'(\d+)')  # p = re.compile(r'\d+') 结果也是一样
>>> print p.findall('one1two2three3four4')
['1', '2', '3', '4']

split
按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。
>>> p = re.compile(r'\d+')
>>> print p.split('one1two2three3four4')
['one', 'two', 'three', 'four', '']

sub
根据正则查找，然后使用规则替换查找到的字符，替换后的字符重新填回原位。\1 代表查到的字符。

>>> txtstr=r"pages of *World Wide Spam*, Inc*mao*,"
>>> pattern = re.compile(r'\*(.+?)\*')
>>> pattern.findall(txtstr)
['World Wide Spam', 'mao']
>>> pattern.sub(r'<em>\1</em>',txtstr)
'pages of <em>World Wide Spam</em>, Inc<em>mao</em>,'

下面这种情况是有\2的，一般只使用\1
sub可以自定义函数，\1代表group(1)
>>> p = re.compile(r'(\w+) (\w+)')
>>> s = 'i say, hello world!'
>>> p.findall(s)
[('i', 'say'), ('hello', 'world')]
>>> p.sub(r'<em>\1</em>',s)
'<em>i</em>, <em>hello</em>!'


python项目1心得

面向对象编程，分模块设计，每个模块均有超类（接口）
工厂类调用各模块超类完成任务
模块之间直接调用，也使用超类
类静态变量，对象之间可以共享访问
超类设计中 callback getattr callable 很有用，参考：Chapter20/listing20-4.py: The Handlers (handlers.py)